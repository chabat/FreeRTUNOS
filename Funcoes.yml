(queue.c) xQueueGenericReceive():
{
  - Verifica se a fila existe;
  - Entra na região crítica;
  Se houver alguma mensagem na fila esperando ser lida:
    - Inicie a leitura pelo pc.ReadFrom;
    - Copie um item para o buffer através de prvCopyDataFromQueue.
        Se não estiver somente observando a fila:
          - Diminua a quantidade de mensagens esperando.
          Se estiver usando mutexes e a fila é um mutex:
            - Será incrementado a quantidade de vezes que aquele mutex foi pego através de pvTaskIncrementMutexHeldCount,
            além de ser atribuido a pxMutexHolder o tcb da tarefa que o pegou.
          Se houver alguma mensagem esperando para colocar um dado nessa fila (pode ser um outro mutex?):
            - Coloque ele na lista de pronto e libere o uso do escalonador.
        Se tá só observando:
          - Resete o ponteiro de leitura.
          Se a lista não está vazia e tem alguma tarefa esperando para ler da fila:
            - Coloque essa tarefa na lista de pronto e libere o uso do escalonador.

  Caso contrário:
    Se o tempo de espera for 0:
      - Saia de região crítica e retorne um erro dizendo que a queue está vazia.
    Caso contrário, mas é a primeira vez que está verificando:
      - Defina o xEntryTimeSet e defina o timeout;
    - Saia da região crítica.
  - Suspenda o escalonador e bloqueie a fila, para garantir a atomicidade.
  Se o timeout ainda não expirou:
    Se a fila não está vazia:
      Se é um mutex e a fila é do tipo mutex:
        - Então irá acontecer a herdagem de prioridade, através de vTaskPriorityInherit e vai sair da região crítica.
      - Coloque o tcb na lista de eventos de mensagens que estão esperando para ler da fila.
      - Desbloqueie e fila.
      - Resuma o escalonador.
    Caso contrário:
      - Tente de novo.
  Se o timeout expirou:
    - Retorn erro que a fila está vazia.
}

(tasks.c)	vTaskPriorityInherit():
{
  Se o mutex atual não for nulo e a prioridade do TCB atual é maior que a do TCB que possui o mutex:
    - Se a sua prioridade não estiver sendo usada para alguma outra coisa (??), altere ela para a prioridade da tarefa atual.
    Se o tcb tá na lista de pronto:
      Então ele deve ser movido para a nova lista de maior prioridade.
    Se não:
      Somente herde a prioridade.
}

(queue.c) prvCopyDataFromQueue():
{
  Se a fila tem ao menos um dado:
    - Faça ele receber o próximo item, aumentando em uxItemSize o lugar para ele ler.
    - Se ultrapassar o fim da fila, mude o aponteiramento para ele ler do começo da área de armazenamento.
    - Copie um item para o buffer.
}

(tasks.c) pvTaskIncrementMutexHeldCount():
{
  - Basicamente verifica se o tcb atual não é nulo, pois pode ser a primeira vez que ele está sendo pego.
  Se não for, então incrementará a quantidade de vezes que ele foi pego.
  - Retorna o tcb atual, isso faz com que o pxMutexHolder(pcTail) caso seja a primeira vez já tenha qual é o TCB
  que está segurando aquele mutex.
}

xSemaphoreCreateMutex():
{
  Na verdade é somente uma definição, a função real é xQueueCreateMutex(queueQUEUE_TYPE_MUTEX)
  - Cria uma nova fila e atribui a um ponteiro.
  - Se foi possível criar a queue, ele irá atribuil NULL para pcTail, o que indica que nenhuma tarefa
  pegou aquele mutex.
  - Dirá que a fila é um mutex, atribuindo a pcHead NULL.
  - Coloca NULL em pcWriteTo e pcReadFrom, pois não terá nenhum dado nessas variáveis.
  - Como cada mutex tem um tamanho de um e nenhum dado é copiado a ele, as variáveis uxMessagesWaiting
  e uxItemSize recebem o valor 0 e uxLength recebe valor 1.
  - Coloca as filas como desbloqueadas.
  - Inicialisa as listas de eventos com o valor correto através de vListInitialise (xTasksWaitingToSend e xTasksWaitingToReceive).
  - Inicializa o semaforo com um item lá, dizendo que nenhuma tarefa pegou o semáforo, através da função xQueueGenericSend.
  - Retorna o handle da queue.
}

xQueueGive():
{
  - Se a quantidade de mensagens na fila forem menor que o tamanho dela, então é possível colocá-la lá.
  - Se o tipo da fila é um mutex, então ele vai chamar a função xTaskPriorityDisinherit para o pxMutexHolder
  e vai dar que o pxMutexHolder daquela fila é NULL.
  - Aumenta a quantidade de mensagens esperando por algum dado para chegar na fila, então essa tarefa será desbloqueada.
  - Se ao tentar remover da lista de eventos retornar pdFalse, então a tarefa tem maior prioridade, deste modo deve-se
  liberar o uso do processador imediatamente.
  Se a fila estiver cheia:
    - Se não houver a possibilidade de esperar, então ela vai sair da região crítica e retornar errQUEUE_FULL;
    - Se houver, então será setado um timeout para a tarefa.
}

xTaskPriorityDisinherit():
{
  - Vai decrementar a quantidade de mutexes que o tcb atual segura.
  - Se a prioridade dele mudou, então ele vai devolver a prioridade daquele tcb para a sua prioridade original,
  removendo ele da lista de estado a qual ele pertence e resetando a prioridade dele através de taskRESET_READY_PRIOTIRY.
  - Atribua a prioridade base daquela tarefa.
  - Coloque ele de novo na lista de eventos, agora com sua prioridade base através de listSET_LIST_ITEM_VALUE.
  - Adicione ele à lista de prontos.
  - Retorne pdTRUE.
}

listSET_LIST_ITEM_VALUE():
{
  Vai atribuir o que está em xItemValue de pxListItem o valor xValue.
}

xSemaphoreTake():
{
  - Na verdade é uma chamada de xQueueGerenicReceive, passando como parametros o handle do semaforo e o tempo maximo a esperar.
}
