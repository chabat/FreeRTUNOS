(queue.c) xQueueGenericReceive():
{
  - Verifica se a fila existe;
  - Entra na região crítica;
  Se houver alguma mensagem na fila esperando ser lida:
    - Inicie a leitura pelo pc.ReadFrom;
    - Copie um item para o buffer através de prvCopyDataFromQueue.
        Se não estiver somente observando a fila:
          - Diminua a quantidade de mensagens esperando.
          Se estiver usando mutexes e a fila é um mutex:
            - Será incrementado a quantidade de vezes que aquele mutex foi pego através de pvTaskIncrementMutexHeldCount,
            além de ser atribuido a pxMutexHolder o tcb da tarefa que o pegou.
          Se houver alguma mensagem esperando para colocar um dado nessa fila (pode ser um outro mutex?):
            - Coloque ele na lista de pronto e libere o uso do escalonador.
        Se tá só observando:
          - Resete o ponteiro de leitura.
          Se a lista não está vazia e tem alguma tarefa esperando para ler da fila:
            - Coloque essa tarefa na lista de pronto e libere o uso do escalonador.

  Caso contrário:
    Se o tempo de espera for 0:
      - Saia de região crítica e retorne um erro dizendo que a queue está vazia.
    Caso contrário, mas é a primeira vez que está verificando:
      - Defina o xEntryTimeSet e defina o timeout;
    - Saia da região crítica.
  - Suspenda o escalonador e bloqueie a fila, para garantir a atomicidade.
  Se o timeout ainda não expirou:
    Se a fila não está vazia:
      Se é um mutex e a fila é do tipo mutex:
        - Então irá acontecer a herdagem de prioridade, através de vTaskPriorityInherit e vai sair da região crítica.
      - Coloque o tcb na lista de eventos de mensagens que estão esperando para ler da fila.
      - Desbloqueie e fila.
      - Resuma o escalonador.
    Caso contrário:
      - Tente de novo.
  Se o timeout expirou:
    - Retorn erro que a fila está vazia.
}

(tasks.c)	vTaskPriorityInherit():
{
  Se o mutex atual não for nulo e a prioridade do TCB atual é maior que a do TCB que possui o mutex:
    - Se a sua prioridade não estiver sendo usada para alguma outra coisa (??), altere ela para a prioridade da tarefa atual.
    Se o tcb tá na lista de pronto:
      Então ele deve ser movido para a nova lista de maior prioridade.
    Se não:
      Somente herde a prioridade.
}

(queue.c) prvCopyDataFromQueue():
{
  Se a fila tem ao menos um dado:
    - Faça ele receber o próximo item, aumentando em uxItemSize o lugar para ele ler.
    - Se ultrapassar o fim da fila, mude o aponteiramento para ele ler do começo da área de armazenamento.
    - Copie um item para o buffer.
}

(tasks.c) pvTaskIncrementMutexHeldCount():
{
  - Basicamente verifica se o tcb atual não é nulo, pois pode ser a primeira vez que ele está sendo pego.
  Se não for, então incrementará a quantidade de vezes que ele foi pego.
  - Retorna o tcb atual, isso faz com que o pxMutexHolder(pcTail) caso seja a primeira vez já tenha qual é o TCB
  que está segurando aquele mutex.
}
