******************************************************************************************************************************************************
***********************************************************SESSÂO DE FUNÇÕES**************************************************************************
******************************************************************************************************************************************************

(Arduino_FreeRTOS.h) portYIELD_WITHIN_API:
Macro que define portYIELD_WITHIN_API como portYIELD

(Arduino_FreeRTOS.h) configASSERT:
*Usada para evitar que o programa execute após essa chamada caso o valor do parâmetro seja igual a 0. Isso facilita
a depuração, pois indica o arquivo e a linha do erro.

(heap_3.c) pvPortMalloc:
-Suspende o escalonador através de uma chamada de vTaskSuspendAll
-Aloca um bloco do tamanho em bytes passado via parâmetro através de uma chamada de malloc(), atribuindo à variável de retorno
  o retorno da chamada, que é um ponteiro para o início do bloco.
-Chama a macro de tracing traceMALLOC, passando como parametro o ponteiro para inicio do bloco e tamanho do bloco em bytes
-Resume o escalonador através de uma chamda de xTaskResumeAll
-Caso configUSE_MALLOC_FAILED_HOOK estiver definida e o retorno da chamada a função malloc() seja NULL, indicando que não houve espaço
suficiente na heap para a alocação ser concluída com sucesso, é chamada a função vApplicationMallocFailedHook(). Essa função é um hook, ou
chamada de callback que se definida e configurada, será chamada se o retorno de malloc() for NULL.

(list.h) listLIST_IS_EMPTY():
*Macro para checar se uma lista está vazia, apenas vê se o número de itens é 0.

(list.h) listGET_OWNER_OF_HEAD_ENTRY():
-> Recebe como parametro a lista da qual se deseja obter o dono.

-> Macro que obtém o  do dono do primeiro elemento numa lista. Listas geralmente são ordenadas de maneira crescente
em relação aos valores dos itens.

-> Essa função retorna o membro pxOwner do primeiro item da lista. O parametro pxOwner de um item de lista é um
ponteiro para o objeto que é dono daquele item da lista. No escalonador, normalmente é um bloco de contro de tarefa (TCB).
O parametro pxOwner efetivamente cria uma ligação de ida e volta entre o item e seu dono.

*(como faz isso usando end->next->owner?)

(list.h) listTEST_LIST_ITEM_INTEGRITY():
*Macro que checa a integridade do item de lista passado como parâmetro. Faz isso comparando um valor da estrutura do item a um valor predeterminado,
pode conseguir detectar sobrescrita dos valores na memória.

(list.c) uxListRemove:
*Remove o item passado por parâmetro de sua respectiva lista (o item tem o ponteiro para sua lista).
Retorna o número de elementos que permanecem na lista.

-Obtém a lista a qual o item pertence do própio item
-Arruma os encadameantos da lista (liga os elementos anterior e próximo do item)
-mtCOVERAGE_TEST_DELAY (usado durante testes de cobertura de decisão)
-Garante que o índice da lista (pxIndex) seja deixado apontando para um item válido->
  --Caso o índice esteja apontando para o item removido, aponta para o anterior dele.
  --Caso contrário, apenas mtCOVERAGE_TEST_MARKER
-Seta o container do item (Lista ao qual pertence) como NULL
-Decrementa o número de itens da listas
-Retorna o número de itens restantes.

(list.c) vListInitialise:
*Recebe como parâmetro uma estrutura do tipo List_t e vai ajustar os ponteiros, tendo um ponteiro que marca o fim da fila (e.g. aponta para o fim dela),
irá colocar um valor muito grande no fim, para que permaneça no final, assim o fim da fila sempre ficara lá. além de colocar o proximo e anterior itens da fila apontando
para o fim (provavelmente para dizer que a lista não contém nenhum membro).

(list.c) vListInsertEnd():
*Insere um item no final da lista passada como parâmetro

-Checa a integridade da lista e do item que está sendo inserido comparando valores de sua estrutura com uma constante, através de chamadas para
listTEST_LIST_INTEGRITY() e listTEST_LIST_ITEM_INTEGRITY().
-Atribui o próximo do elemento sendo inserido como o pxIndex da fila.
-Atribui o anterior do elemento sendo inserido como o anterior do pxIndex da fila.
-mtCOVERAGE_TEST_DELAY (usado durante testes de cobertura de decisão)
-Atribui ao próximo do anterior do pxIndex e ao anterior do pxIndex o novo item
-Salva no item em qual container (lista) ele se encontra
-incrementa o número de elementos na fila

(port.c) vPortYield:
*Essa função é responsável pela troca "manual" de contexto.

(portmacro.h) portYiELD:
*Macro que define portYiELD() como vPortYield.

(queue.c) xQueueCreate()(xQueueGenericCreate):
*Na verdade é usada assim (como xQueueCreate) para que só precise receber o valor do tamanho da queue e seu comprimento,
mas na verdade ela chama a xQueueGenericCreate, dando o valor de queueQUEUE_TYPE_BASE (apenas utilizado para tracing, mas é definido como 0).

-Remove warnings do compilador caso configUSE_TRACE_FACILITY não esteja ativada, explicitando a variável ucQueueType.

-Verifica se o comprimento da fila é maior que 0 com uma chamada de configASSERT, para evitar erros.

-Se o tamanho de cada item for 0, então não vai haver uma área de armazenamento de queue (possivelmente o único interesse é acessar os metadados da fila). Define o tamanho da fila em bytes para 0.

-Caso contrário, o tamanho da fila em bytes será o comprimento da fila vezes o tamanho de cada item mais 1. Esse byte adicional serve para fazer wrap checking mais rápido (?).

-Aloca o espaço para a estrutura da fila mais o tamanho da área de armazenamento em bytes.

-Caso a alocação tenha sido bem sucedida->
  --Se o tamanho do item for 0, ele vai fazer com que o ponteiro pcHead aponte para a própria estrutura da queue, por que é um endereço garantidamente dentro da memória mapeada. O valor não pode ser NULL
  pois isso é usado para indicar que a fila é um mutex.

  --Caso contrário, fará com que pcHead aponte para o início da área de armazenamento, pulando os dados estruturais da fila.

  -Atualiza os dados estruturais da fila uxQueueLenght e uxItemSize;
  -Chama a função xQueueGenericReset para resetar o estado da fila.
  -Caso o tracing estiver ativado, atribui ao tipo da queue o valor de ucQueueType (nesse caso é um unsigned char).
  -Se estiver usando conjunto de queues, então atribui ao ponteiro de container dessa queue o valor NULL, isso quer dizer que ela não pertence a nenhum conjunto de filas.
  -Chama a macro de tracing traceQUEUE_CREATE.
  -Atribui o endereço (handle) da nova queue à variável de retorna e a retorna para quem chamou a função.


(tasks.c) XtaskCreate(xTaskGenericCreate):
(Definida como XTaskGenericCreate em tasks.h (Os 6 primeiros argumentos são os mesmos da xTaskCreate, os outros dois são o ponteiro para o
buffer da pilha e o ponteiro para região de memória (mais de uma?), esses dois ultimos parametros são passados como NULL)

- Utiliza uma chamada de configASSERT() para verificar se o endereço da função da tarefa é válida.

(CHECAR) - Utiliza uma chamada de configASSERT() para verificar se a prioridade da tarefa a ser criada é menor que a maior prioridade possível.
É usado um bitwise AND com a constante do bit de privilégio negada para remover o bit de privilégio durante a comparação.

-Aloca a memória necessária pelo TCB e pela pilha da nova tarefa com uma chamada à prvAllocateTCBAndStack(), checando se as alocações foram
bem sucedidas. Passa como argumentos para a função a profundidade da pilha e o ponteiro para o buffer da pilha (StackType_t * const puxStackBuffer)
que inicialmente é NULL, no caso de uma chamada a xTaskCreate.

-Caso a proteção de memória estivesse ativada (portUSING_MPU_WRAPPERS == 1), aconteceriam checagens para ver se a função deve rodar em modo
previlegiado e chacagens para ver se a função proveu a propria pilha ou se ela foi alocada dinamicamente. No ultimo caso, é necessario fazer
a liberação de memoria caso a função for terminada.

-Calcula o topo do endereço da pilha. Isso depende se a pilha cresce dos endereços altos ou baixos da memória.

-Configura o TCB recém alocado com o estado inicial da tarefa com uma chamada à função
prvInitialiseTCBVariables.

-Inicializa a pilha do TCB para parecer com que a tarefa já estivesse rodando, mas tivesse sido interrompida
pelo escalonador (com uma chamada de pxPortInitialiseStack). O endereço de retorno é setado para o início da função da tarefa. Uma vez que a pilha tenha
sido inicializada a variável de topo da pilha é atualizada.

-Caso tenha sido passado um endereço de variável para armazenar o handle, ele é atribuído a essa variável.

-Entra numa região crítica para garantir que interrupções não acessem as listas de tarefa enquanto elas estão
sendo atualizadas. Isso é feito com uma chamada de taskENTER_CRITICAL().

-Aumenta o contador de tarefas (uxCurrentNumberOfTasks).

-Se o TCB atual (pxCurrentTCB) for igual a NULL ->
  -- Como não há outra tarefa ou estão todas suspensas, essa se torna a atual (pxCurrentTCB =  pxNewTCB)
  -- Caso essa tenha sido a primeira tarefa a ser criada, é necessário inicializar as listas de tarefa, chama a função prvInitialiseTaskLists().
-Caso hajam outras tarefas rodando no momento que esta foi criada ->
  --Caso o escalonador ainda não esteja executando e essa tarefa tenha maior prioridade que as outras, faça dessa tarefa a tarefa atual.

-Incrementa um contador de tarefas criadas (uxTaskNumber++)

-Caso a funcionalidade de tracing (configUSE_TRACE_FACILITY) esteja ativada, atribui o número do contador previamente incrementado ao campo uxTCBNumber da tarefa. Somente para propósitos de tracing.

-Aqui uma macro de tracing pode ser executada se previamente definida (traceTASK_CREATE( pxNewTCB ))

-Adiciona a tarefa à lista de pronto com uma chamada à prvAddTaskToReadyList().

-Atribui pdPASS à variável de retorno, indicando que a tarefa foi criada com sucesso.

-A macro portSETUP_TCB(pxNewTCB) é chamada, ela é definida em Arduino_FreeRTOS.h como ( void )pxTCB.

-Sai da Região Crítica com uma chamada de taskEXIT_CRITICAL()

-Caso o TCB não possa ter sido alocado, atribui um erro indicando isso à variável de retorno e chama
uma macro de tracing (traceTASK_CREATE_FAILED())

-Caso o retorno da tarefa esteja marcado como pdPASS, o escalonador esteja rodando e atarefa criada tenha
maior prioridade que a sendo executada atualmente, troca de contexto com uma chamada de taskYIELD_IF_USING_PREEMPTION()

-Retorna o resultado de todo o processo a quem chamou a função

(tasks.c) prvAllocateTCBAndStack:
*Se a pilha cresce para baixo (portSTACK_GROWTH < 0), então aloca a pilha depois o TCB. Caso contrário (portSTACK_GROWTH > 0) aloca o tcb, depois a pilha.
No caso do port para Arduino Uno, a pilha cresce pra baixo. Nesse caso não faz muita diferença, uma vez que tudo é controlado pelo próprio malloc.
Porém em outras arquiteturas, isso deve ser considerado.

*De onde vem a memória depende da implementação de pvPortMalloc

-Caso a pilha cresça para cima->
  --Aloca espaço para o TCB utilizando pvPortMalloc()
  --Se alocado o TCB com sucesso, aloca o espaço para a pilha da tarefa utilizando pvPortMallocAligned(), armazenando no TCB o endereço para a base da pilha.
    ---Caso não seja possível alocar a pilha, libera o espaço anteriormente alocado para o TCB e o seta como NULL

-Caso a pilha cresça para baixo->
  -Aloca o espaço para a pilha da tarefa utilizando pvPortMallocAligned()
  -Se alocada a pilha com sucesso, aloca espaço para o TCB utilizando pvPortMalloc()
  -Caso o TCB tenha sido alocado com sucesso, armazena o ponteiro para o inicio da pilha no TCB, do contrário, libera o espaço alocado para a pilha.

-Caso algumas destas constantes esteja habilitada -> configCHECK_FOR_STACK_OVERFLOW, configUSE_TRACE_FACILITY, INCLUDE_uxTaskGetStackHighWaterMark
  --Usa uma chamada de memset para setar a pilha da tarefa com um valor definido por tskSTACK_FILL_BYTE. É usado para checar a "marca d'água" da tarefa, para fins de tracing/debugging.

-Caso alguma alocação falhe, o retorno da tarefa será NULL, e os espaços que foram alocados anterioremente serão liberados.

(tasks.c) prvInitialiseTCBVariables:
-Copia o nome da tarefa passado como parâmetro no campo pcTaskName do TCB, tomando cuidado para não copiar todos os configMAX_TASK_NAME_LEN caracteres, no caso do nome ser menor que o valor da constante.
  Isso é feito para caso a memória depois da string não seja acessível, o que é extremamente improvável.

-Garante que o nome foi terminado com \0, no caso dele ser maior ou igual a configMAX_TASK_NAME_LEN.

-Remove o bit de previlegio do valor da prioridade da tarefa, caso presente, pois o valor é usado como indice de um array.

-Atribui a prioridade à variável uxPriority do TCB.

-Caso o uso de mutexes esteja habilitado, inicia as variáveis do TCB uxBasePriority como uxPriority e uxMutexesHeld como 0.

-Inicializa os itens de lista xGenericListItem e xEventListItem com chamadas à função vListInitialiseItem. Ambos são marcados como não fazendo parte de uma lista.

-Seta o próprio TCB como dono dos itens xGenericListItem e xEventListItem através da macro listSET_LIST_ITEM_OWNER(). Isso acontece para que possamos voltar ao TCB de um item generico numa lista.

-Seta o valor do item de lista xEventListItem para o máximo de prioridades menos a prioridade dele através da macro listSET_LIST_ITEM_VALUE. As listas de eventos sempre são ordenadas por prioridade (Aparentemente em ordem crescente).

-Caso portCRITICAL_NESTING_IN_TCB esteja ativada, inicializa o valor de uxCriticalNesting como 0.

-Caso configUSE_APPLICATION_TASK_TAG esteja ativada, inicializa o valor de pxTaskTag como NULL.

-Caso configGENERATE_RUN_TIME_STATS esteja ativada, inicializa o valor de ulRunTimeCounter como 0.

-Caso portUSING_MPU_WRAPPERS, chama vPortStoreTaskMPUSettings provavelmente para armazenar as configurações de MPU. Essa função não está definida no port para Arduino Uno.
  --Caso contrário, faz um casting pra void de xRegions e usStackDepth (Para evitar warnings?).

-Caso configNUM_THREAD_LOCAL_STORAGE_POINTERS esteja habilitada, inicializa todos os ponteiros de pvThreadLocalStoragePointers como NULL.

-Caso configUSE_TASK_NOTIFICATIONS esteja habilitada, inicializa o valor de ulNotifiedValue como 0 e eNotifyState como eNotWaitingNotification.

-Caso configUSE_NEWLIB_REENTRANT esteja habilitada, chama _REENT_INIT_PTR(&(pxTCB->xNewLib_reent)) para inicializar a estrutura NewLib reent dessa tarefa.



(tasks.c) vTaskSuspendAll:
-Incrementa um contador chamado ++uxSchedulerSuspended, o que indica que o escalonador foi suspenso. Isso não desabilita as interrupções,
trocas de contexto não ocorrem enquanto o escalonador estiver suspenso. Ticks ficarão pendentes até uma chamada de xTaskResumeAll.
Explicação da atomicidade -> http://goo.gl/wu4acr

(tasks.c) xTaskResumeAll:
-Garante através de uma chamada de configASSERT (passando como parâmetro uxSchedulerSuspended) que a chamada para xTaskResumeAll
tenha uma chamada anterior de vTaskSuspendAll correspondente.

    *É possível que enquanto o escalonador estava suspenso, uma tarefa tenha sido removida de uma lista de eventos por causa de um ISR (Interruption service routine).
    Se for o caso, esta tarefa foi adicionada a xPendingReadyList. Assim que o escalonador é resumido, é seguro mover todas as tarefas dessa lista para suas listas
    de "pronta" correspondentes.

-Desabilita interrupções através de uma chamada de taskENTER_CRITICAL
-Decrementa o valor de uxSchedulerSuspended, indicando que o escalonador foi resumido
-Garante que o escalanonador não está mais suspenso e que existam tarefas, caso contrário, usa mtCOVERAGE_TEST_MARKER().

-Enquanto houverem tarefas na lista de tarefas pendentes (xPendingReadyList) (Checa com listLIST_IS_EMPTY()) ->
  --Pega o endereço do TCB da tarefa com listGET_OWNER_OF_HEAD_ENTRY()
  --Remove o xEventListItem e o xGenericListItem do TCB de suas respectivas listas com uxListRemove()
  --Adiciona a tarefa a lista de pronto com prvAddTaskToReadyList();
  --Se a tarefa movida para pronto tem prioridade(pxTCB->uxPriority) maior que a tarefa atual(pxCurrentTCB->uxPriority), então uma troca de contexto deve
  ser realizada (xYieldPending = pdTRUE)

*Se algum tick ocorreu enquanto o escalonador estava suspenso, então eles devem ser processados agora. Isso garante que não ocorram erros com o contador
de ticks, e que quaisquer tarefas atrasadas sejam resumidas no tempo correto.

-Se há ticks pendentes, enquanto houverem ticks pendentes ->
  --Chama a função xTaskIncrementTick() para incrementar o contador de ticks e ver se o novo valor vai causar o desbloqueio de alguma tarefa.
  --Caso o retorno da chamda de xTaskIncrementTick() não for falso, será necessário uma troca de contexto, portanto xYieldPending = pdTRUE.
  --Decrementa o número de ticks pendentes

-Se há troca de contexto pendente ->
  --Caso configUSE_PREEMPTION seja diferente de 0, seta o valor de xAlreadyYielded para pdTRUE, indicando que vai haver troca de contexto
  --Caso a preempção esteja ativada, troca de contexto com uma chamada de taskYIELD_IF_USING_PREEMPTION

-Habilita novamente as interrupções através de uma chamada de taskEXIT_CRITICAL()


(tasks.c) taskYIELD_IF_USING_PREEMPTION:
  -Caso configUSE_PREEMPTION seja 0, é definida como uma macro vazia.
  -Caso contrário, é definida como portYIELD_WITHIN_API

  *Isso é feito por que caso o escalonador cooperativo esteja sendo usado então uma troca de contexto não deve ser realizada
  apenas por que uma tarefa de maior prioridade foi acordada.

(tasks.c) prvAddTaskToReadyList():
*Macro para adicionar a tarefa do TCB passado como parâmetro no fim da lista de pronto apropriada.

-Macro de tracing traceMOVED_TASK_TO_READY_STATE
-Verifica e possivelmente atualiza a prioridade da maior tarefa pronta com uma chamada para taskRECORD_READY_PRIORITY
-Adiciona o TCB da tarefa a fila de tarefas prontas com uma chamada de vListInsertEnd()

(tasks.c) taskRECORD_READY_PRIORITY():
*Macro para atualizar a variável uxTopReadyPriority, que guarda a prioridade da tarefa pronta com maior prioridade.

-Se a a prioridade da tarefa passada como parâmetro for maior que a guardada em uxTopReadyPriority, atualiza uxTopReadyPriority
para a prioridade passada como parametro.
