#### ESTRUTURAS:

(list.h) List_t{
  listFIRST_INTEGRITY_CHECK_VALUE:{
    configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES: Existe uma definição dela, que é
    usada para fazer uma verificação básica de corrupção de dados, que caso ela
    não esteja definida, será definida como 0.
  } Setado para um valor conhecido se a definição acima é 1.
  configLIST_VOLATILE{
    Se não tá definido, defina. Isso serve para evitar que o compilador remova trechos de cógido onde poderia dar erro no escalonador.
    Usado para evitar a otimização onde essa variável é usada.
  }uxNumberOfItems: quantos itens tem na fila.
  //Isso aqui parece incompleto
}

(tasks.c) TCB_t(tskTCB){
  (2B) volatile stackType_t pxTopOfStack{ Ponteiro para a localização do ultimo item colocado na pilha da tarefa.
  }
  #ND(0) portUSING_MPU_WRAPPERS { Usado para a proteção da memória, porém no arduino não é utilizada. Se fosse definido as xMPU_SETTINGS deveriam ser
  definidas como parte da port layer, e teria uma flag que diria se a pilha foi alocada dinâmicamente ou estaticamente.
  }
  (10B) ListItem_t xGenericListItem{ É o que define o estado da tarefa. Se a lista que referencia esse item é a lista de pronto, então ele está pronto
  para ir para o escalonador.
  }
  (10B) ListItem_t xEventListItem { Usado para refenciar uma tarefa a partir de uma lista de eventos.
  }
  (1B) UBaseType_t uxPriority { Prioridade. 0 é a mais baixa.
  }
  (2B) StackType_t *pxStack{ Aponta para o começo da pilha.
  }
  (8B) char pcTaskName[ configMAX_TASK_NAME_LEN ] { Nome descritivo da tarefa, tem no máximo tamanho 8(pode mudar conforme FreeRTOSConfig.h)
  }
  #-1 portSTACK_GROWTH { Já definido
    (2B) StackType_t *pxEndOfStack { Se a pilha cresce para cima, é necessário um ponteiro para o fim da pilha.
    }
  }
  #ND(0) portCRITICAL_NESTING_IN_TCB{ definição que pertimirá ou não o critical nesting.
    (1B) UBaseType_t uxCriticalNesting { Se o quão "Nested" a região critica está for guardada no TCB, então é necessário ter uma variável para
    guardar esse valor.volatile
    }
  }
  #0 configUSE_TRACE_FACILITY{ Grava a sequencia em que as tarefas recebem o tempo de processamento do microprocessador.
    (1B) UBaseType_t uxTCBNumber { Contador de quantidade de vezes que TCBs foram criados. Serve para ajudar debuggers para saber quando uma tarefa foi
    deletada e recriada.
    }
    (1B) UBaseType_t uxTaskNumber { Numero utilizado por códigos de rastro (trace) de terceiros.
    }
  }
  #1 configUSE_MUTEXES{ Caso o uso de mutexes esteja ligado.
    (1B) UBaseType_t uxBasePriority{ a ultima prioridade atribuida a tarefa. Usado pelo mecanismo de herança de prioridades.
    }
    (1B) UBaseType_t uxMutexesHeld{ Numero de mutexes que a tarefa está segurando (não temos certeza, entretanto).
    }
  }
  #ND(0) configUSE_APPLICATION_TASK_TAG{ Habilita ou não o uso de valores de tag para uma tarefa. Tag é um valor que pode ser atribuido a cada
  tarefa e pode ser usado pela aplicação para macros de tracing. O kernel não utiliza esse recurso. Esse valor pode ser qualquer coisa,
  até uma função de callback.
    (1B) TaskHookFunction_t { é uma variável que recebe um valor, passado por parametro como ponteiro para void, mas que é do tipo BaseType_t.
    o parâmetro pode ser usado para passar qualquer valor para a função. } pxTaskTag{ valor dado a tag da tarefa.
    }
  }
  #ND(0) configNUM_THREAD_LOCAL_STORAGE_POINTERS{ Usado para guardar um valor dentro do TCB. Esse valor é específico da thread em questão. Alternativa
  para alguns casos de variáveis globais em ambientes multithreads.
    (2B) void *pvThreadLocalStoragePointers[ configNUM_THREAD_LOCAL_STORAGE_POINTERS]{ array de ponteiros para void, usado para guardar valores.
    possui uma função específica para definir e ler um valor no array de ponteiros (vTastkSetThreadLocalStoragePointer() e
    pvTastkGetThreadLocalStoragePointer()).
    }
  }
  #ND(0) configGENERATE_RUN_TIME_STATS{ usado para coletar informações acerca do uso do processamento que foi usado por cada tarefa (tempo absoluto e percentual).
  A função vTaskGetRunTimeStats() é usada para mostrar essas informações em um formato tabular.
    (4B) uint32_t ulRunTimeCounter{ Quantidade de tempo que a tarefa passou no estado running.
    }
  }
  #ND(0) configUSE_NEWLIB_REENTRANT{ Habilita o uso de uma biblioteca popular para sistemas embarcados (NewLib). #ND.
    (0B) struct _reent xNewlib_reent{ Aparentemente não está definido em lugar algum. Portanto o dono da aplicação deve definir essa estrutura.
    }
  }
  #ND(1) configUSE_TASK_NOTIFICATIONS{ Definido caso a funcionalidade de notificações diretas das tarefas deseja ser usada. Cada tarefa consome 8 bytes adicionais
  de RAM quando essa funcionalidade está incluida (Conferir se no arduino AVR é 8bytes mesmo).
    (4B) volatile uint32_t ulNotifiedValue{ Variável que armazenará os valores das notificações.
    }
    (2B) volatile eNotifyValue eNotifyState{ Variável que guarda o estado da notificação.
    }
  }
}

(list.h) ListItem_t(xLIST_ITEM){
  listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE { Não é intencionado para ser usado pela aplicação, mas sim para testes dos desenvolvedores
  do FreeRTOS. }
  (2B) configLIST_VOLATILE{ Já Definido. } TickType_t xItemValue { É o valor sendo listado, em muitos casos usado para ordenar a
  lista em ordem decrescente.
  }
  (2B) xLIST_ITEM *configLIST_VOLATILE pxNext{ Ponteiro para o proximo listItem_t na lista. }
  (2B) xLIST_ITEM *configLIST_VOLATILE pxPrevious { Ponteiro para o anterior listItem_t na lista. }
  (2B) void *pvOwner { Ponteiro para o objento (normalmente o TCB) que contém esse item. }
  (2B) void *configLIST_VOLATILE pvContainer{ Ponteiro para a lista no qual este item está colocado, se existir. }
  listSECOND_LIST_ITEM _INTEGRITY_CHECK_VALUE {Já Definido }
} (10B)

(tasks.c) eNotifyValue{ é um enumerador, onde
  eNotWaitingNotification é 0
  eWaitingNotification é 1
  eNotified é 2
}

(portmacro.h) MemoryRegion_t (xMemoryRegion){
  void *pvBaseAddress {Ponteiro para o endereço base da região de memória.}
  uint32_t ulLengthInBytes {Comprimento em bytes}
  uint32_t ulParameters {Define como a tarefa é permitida acessa a região da memória, e pode receber um OR bit a bit dos seguintes valores:
    portMPU_REGION_READ_WRITE
    portMPU_REGION_PRIVILEGED_READ_ONLY
    portMPU_REGION_READ_ONLY
    portMPU_REGION_PRIVILEGED_READ_WRITE
    portMPU_REGION_CACHEABLE_BUFFERABLE
    portMPU_REGION_EXECUTE_NEVER
  }
}

(queue.c) Queue_t (xQUEUE){
  int8_t *pcHead{ Aponta para o começo da area de armazenamento da Queue.
  }
  int8_t *pcTail{ Aponta para o byte no fim da área de armazenamento da Queue. É alocado um byte a mais só pra isso.
  }
  int8_t *pcWriteTo{ Aponta para o próximo espaço vazio da área de armazenamento.
  }
  union{ Usado pra reduzir memória.
    int8_t *pcReadFrom{ Aponta para o ultimo lugar que um item enfileirado foi lido quando a estrutura é usada como uma fila.}
    UBaseType_t uxRecursiveCallCount{ Mantém um contador do nível da recursão dos mutexes, e.g. quantas vezes aquele mutex foi pego na recursão
    quando a estrutura está sendo usada como mutex.
  }
  List_t xTasksWaitingToSend lista de todas as tarefas que estão bloqueadas aguardando para escreverem nessa fila. (São guardadas em ordem de prioridade).
  List_t xTasksWaitingToReceive lista de todas as tarefas que estão bloqueadas aguardando para lerem dessa fila. (Também em ordem de prioridade).
  UBaseType_t uxMessagesWaiting Número de mensagens que estão na fila.
  UBaseType_t uxLength comprimento da fila. (É definido pelo numero de dados que ela guardará, não o número de bytes).
  UBaseType_t uxItemSize tamanho de cada item que essa fila irá manter.
  UBaseType_t xRxLock Guarda o número de dados recebidos da fila enquanto ela estava bloqueada.
  UBaseType_t xTxLock Guarda o número de dados colocados na fila enquanto ela estava bloqueada.
  #ND(0) configUSE_TRACE_FACILITY{
    UBaseType_t uxQueueNumber;
    UBaseType_t ucQueueType;
  }
  configUSE_QUEUE_SETS{
    QueueDefinition *pxQueueSetContainer{ Estou em dúvida, se ele segura as queues, ou seja se ele é um container dessa queue, ou se ele aponta pra qual queue esse carinha
    aqui pertence.
    }
  }
}

#### TIPOS:

(queue.h) QueueHandle_t { é um ponteiro para void.
}

(portmacro.h) StackType_t(portSTACK_TYPE){ é um uint8_t
}

(portmacro.h) uint32_t{ Unsigned long. 4 bytes .
}

(portmacro.h) uint16_t{ Unsigned short. 2 bytes.
}

(portmacro.h) uint8_t{ Unsigned char. 1 byte.
}

(portmacro.h) UBaseType_t{ Unsigned char de valor 1 byte.
}

(portmacro.h) TickType_t{ É um uint16_t ou um uint32_t dependendo da definição de configUSE_16_BIT_TICKS, que nosso caso é 1, então é um uint16_t .
}

*O tamanho de um ponteiro no arduino é de 2 Bytes.

#### FUNÇÕES:

(Tasks.c) VtaskStartScheduler{
   Cria a tarefa idle guardando ou não o valor dela, de acordo com a constante INCLUDE_xTaskGetIdleHandle.
   xTaskCreate();{ Retorna pdPASS se a tarefa foi criada corretamente, errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY caso contrário.
   }
   configUSE_TIMERS{ Usada para incluir a funcionalidade de timers de software. 1 para incluir, 0 caso contrário.
   }
   xTimerCreateTimerTask(){
   }
}

(tasks.c) XtaskCreate{ Definida como XtaskGenericCreate em tasks.h (Os 6 primeiros argumentos são os mesmos da xTaskCreate,
 os outros dois são o ponteiro para o  buffer da pilha e o ponteiro para região de memória (mais de uma?), esses dois ultimos parametros
 são passados como NULL)
   configASSERT():{ O primeiro irá verificar se o ponteiro não é nulo. O segundo provavelmente é para verificar
   se a prioridade da tarefa a ser criada é menor que a maior prioridade possível. É usado um bitwise and com a
   constante do bit de privilégio negada para remover o bit de privilégio durante a comparação.
   }
   prvAllocateTCBAndStack() { }
}

(FreeRTOS.h) configASSERT{ Usada para evitar que o programa execute após essa chamada caso o valor do parâmetro seja igual a 0. Isso facilita
a debugação, pois indica o arquivo e a linha do erro.
}

(tasks.c) prvAllocateTCBAndStack{
   Se a pilha (portSTACK_GROWTH) cresce para baixo( < 0), então aloca a pilha depois o tcb. Caso contrário (> 0) aloca o tcb depois a pilha.
   No nosso caso, a pilha cresce pra baixo. Nesse caso não faz muita diferença, uma vez que tudo é controlado pelo próprio malloc. Porém em outras
   arquiteturas, isso deve ser considerado.

   Caso a pilha cresça para baixo:
     -Aloca espaço para o TCB utilizando pvPortMalloc()
     -Se alocado o TCB com sucesso, aloca o espaço para a pilha da tarefa utilizando pvPortMallocAligned(), armazenando no TCB o endereço para a
        base da pilha.
     -Caso não seja possível alocar a pilha, libera o espaço anteriormente alocado para o TCB e o seta como NULL

   Caso a pilha cresça para cima:
     -Aloca o espaço para a pilha da tarefa utilizando pvPortMallocAligned()
     -Se alocada a pilha com sucesso, aloca espaço para o TCB utilizando pvPortMalloc()
     -Caso o TCB tenha sido alocado com sucesso, armazena o ponteiro para o inicio da pilha no TCB, do contrário, libera o espaço alocado para
       a pilha.

   *De onde vem a memória depende da implementação de pvPortMalloc
   }

  (heap_3.c) pvPortMalloc{
    -Suspende o escalonador através de uma chamada de vTaskSuspendAll
    -Aloca um bloco do tamanho em bytes passado via parâmetro através de uma chamada de malloc, atribuindo à variável de retorno
      o retorno da chamada, que é um ponteiro para o início do bloco.
    -Chama a macro de tracing traceMALLOC, passando como parametro o ponteiro para inicio do bloco e tamanho do bloco em bytes

  }

  (tasks.c) vTaskSuspendAll {
    Suspende o escalonador sem desabilitar as interrupções, trocas de contexto não ocorrem enquanto
    o escalonador estiver suspenso. Ticks ficarão pendentes até uma chamada de xTaskResumeAll.

    -Incrementa um contador chamado ++uxSchedulerSuspended, o que indica que o escalonador foi suspenso.


    Explicação da atomicidade: http://goo.gl/wu4acr
  }

  (tasks.c) xTaskResumeAll (MPU_xTaskResumeAll){
    -Garante através de uma chamada de configASSERT (passando como parâmetro uxSchedulerSuspended) que a chamada para xTaskResumeAll
      tenha uma chamada passada de vTaskSuspendAll correspondente.

    *É possível que enquanto o escalonador estava suspenso, uma tarefa tenha sido removida de uma lista de eventos por causa de um ISR (Interruption service routine).
    Se for o caso, esta tarefa foi adicionada a xPendingReadyList. Assim que o escalonador é resumido, é seguro mover todas as tarefas dessa lista para suas listas
    de "pronta" correspondentes.

    -Desabilita interrupções através de uma chamada de taskENTER_CRITICAL
    -Decrementa o valor de uxSchedulerSuspended, indicando que o escalonador foi resumido
    -Garante que o escalanonador não está mais suspenso e que hajam tarefas, caso contrário, usa mtCOVERAGE_TEST_MARKER().
    -Enquanto houverem tarefas na lista de tarefas pendentes (xPendingReadyList) (Checa com listLIST_IS_EMPTY()):
      *Pega o endereço do TCB da tarefa com listGET_OWNER_OF_HEAD_ENTRY()
      *Remove o xEventListItem e o xGenericListItem do TCB de suas respectivas listas com uxListRemove()
      *Adiciona a tarefa a lista de pronto com prvAddTaskToReadyList();
      *Se a tarefa movida para pronto tem prioridade maior que a tarefa atual(pxCurrentTCB->uxPriority), então uma troca de contexto deve
      ser realizada (xYieldPending = pdTRUE)
  }

  (list.h) listLIST_IS_EMPTY(){
    Macro para checar se uma lista está vazia, apenas vê se o número de itens é 0.
    Retorna um BaseType_t.
  }

  (list.h) listGET_OWNER_OF_HEAD_ENTRY(){
    Macro que obtém o endereço do dono do primeiro elemento numa lista, no escalonador, geralmente um TCB.
    Faz isso acessando o dono do último elemento na listas
    (como faz isso usando end->next->owner?)
  }

  (list.c) uxListRemove(){
    remove o item passado por parâmetro de sua respectiva lista (o item tem o ponteiro para sua lista).
    Retorna o número de elementos que permanecem na lista.
    -Obtém a lista a qual o item pertence do própio item
    -arruma os encadameantos da lista (liga os elementos anterior e próximo do item)
    -mtCOVERAGE_TEST_DELAY (usado durante testes de cobertura de decisão)
    -Garante que o índice da lista (pxIndex) seja deixado apontando para um item válido:
      Caso o índice esteja apontando para o item removido, aponta para o anterior dele.
      Caso contrário, apenas mtCOVERAGE_TEST_MARKER
    -Seta o container do item (Lista ao qual pertence) como NULL
    -Decrementa o número de itens da listas
    -Retorna o número de itens restantes.
  }

  (tasks.c) prvAddTaskToReadyList(){
    Macro para adicionar a tarefa do TCB passado como parâmetro no fim da lista de pronto apropriada.
    *Macro de tracing traceMOVED_TASK_TO_READY_STATE
    *Verifica e possivelmente atualiza a prioridade da maior tarefa pronta com uma chamada para taskRECORD_READY_PRIORITY
    *Adiciona o TCB da tarefa a fila de tarefas prontas com uma chamada de vListInsertEnd()
  }

  (tasks.c) taskRECORD_READY_PRIORITY(){
    Macro para atualizar a variável uxTopReadyPriority, que guarda a prioridade da tarefa pronta com maior
    prioridade
    *Se a a prioridade da tarefa passada como parâmetro for maior que a guardada em uxTopReadyPriority,
    atualiza uxTopReadyPriority para a prioridade passada como parametro.
  }

  (list.c) vListInsertEnd(){
    Insere um item no final da lista passada como parâmetro
    -Checa a integridade da lista e do item que está sendo inserido comparando valores de sua estrutura com uma constante, através de chamadas para
    listTEST_LIST_INTEGRITY() e listTEST_LIST_ITEM_INTEGRITY().
    -Atribui o próximo do elemento sendo inserido como o pxIndex da fila.
    -Atribui o anterior do elemento sendo inserido como o anterior do pxIndex da fila.
    -mtCOVERAGE_TEST_DELAY (usado durante testes de cobertura de decisão)
    -Atribui ao próximo do anterior do pxIndex e ao anterior do pxIndex o novo item
    -Salva no item em qual container (lista) ele se encontra
    -incrementa o número de elementos na fila
  }

  (list.h) listTEST_LIST_INTEGRITY(){
    Macro que checa a integridade da lista passada como parâmetro. Faz isso comparando um valor da estrutura lista a um valor predeterminado, pode conseguir detectar
    sobrescrita dos valores na memória.
  }

  (list.h) listTEST_LIST_ITEM_INTEGRITY(){
    Macro que checa a integridade do item de lista passado como parâmetro. Faz isso comparando um valor da estrutura do item a um valor predeterminado,
    pode conseguir detectar sobrescrita dos valores na memória.
  }
}

--:)

(timers.c) xTimerCreateTimerTask{ Se use timers está em 1, checa se a infraestrutura usada pelo timer de software foi criada e inicializada.
    prvCheckForValidListAndQueue(){ Entra na região crítica e verifica se a queue já foi inicializada, em caso negativo, inicializa as listas de timer e cria
    a fila do timer.
  }
}

(timers.c) prvCheckForValidListAndQueue{ Verifica se a lista dos timers ativos que são referenciados, junto da fila usada para se comunicar com os timers de
software foram inicializados.
  (task.h) taskENTER_CRITICAL(){ Entra na região crítica. Definida como (portmacro.h) portENTER_CRITICAL(), que nada mais é que um código em assembly para evitar interrupções (sejam elas globais ou interrupções
  abaixo de uma certa prioridade), se a funcionalidade configMAX_SYSCALL_INTERRUPT_PRIORITY não estiver sendo usada, então serão desabilitadas as interrupções globalmente.
  }
  Se a fila do timer ainda não foi inicializada/criada, crie duas listas de timer e diga que essas filas são as filas atual, depois crie a fila do timer.
  vListInitialise();
  xQueueCreate();
}vListInsertEnd

(list.c) vListInitialise{ Recebe como parâmetro uma estrutura do tipo List_t e vai ajustar os ponteiros, tendo um ponteiro que marca o fim da fila (e.g. aponta para o fim dela),
irá colocar um valor muito grande no fim, para que permaneça no final, assim o fim da fila sempre ficara lá. além de colocar o proximo e anterior itens da fila apontando
para o fim (provavelmente para dizer que a lista não contém nenhum membro).
}

(timers.c) xQueueCreate(){ Na verdade é usada assim para que só precise receber o valor do tamanho da queue e seu comprimento, mas na verdade ela chama a xQueueGenericCreate,
dando o valor de queueQUEUE_TYPE_BASE (que é de uso interno apenas, mas é definido como 0).
  Queue_t *pxNewQueue; { um ponteiro para a nova queue que será criada (com o malloc). }
  size_t xQueueSizeInBytes;
  QueueHandle_t xReturn;
  - Vai verificar se o tamanho da fila é maior que 0, para evitar erros.
  Se o tamanho de cada item for 0, então ele diz que não vai haver uma área de armazenamento de queue.
}

**Macros de Tracing: Permitem coleta de dados sobre o comportamento da aplicação durante a execução. Pontos chave do sistema possuem macros vazias
que podem ser redefinidas para prover funcionalidades de tracing. As macros vazias não afetam o funcionamento da aplicação.

#### MAPAS DE FUNÇÕES:

vTaskStartScheduler()
  xTaskCreate() (xTaskGenericCreate)
    configASSERT()
    configASSERT()
    prvAllocateTCBAndStack()
      pvPortMalloc()
        vTaskSuspendAll()
        traceMALLOC()
        xTaskResumeAll()
          configASSERT()
          taskENTER_CRITICAL()
            listLIST_IS_EMPTY()
            listGET_OWNER_OF_HEAD_ENTRY()
            uxListRemove()
              mtCOVERAGE_TEST_DELAY()
              mtCOVERAGE_TEST_MARKER()
              prvAddTaskToReadyList()
                traceMOVED_TASK_TO_READY_STATE()
                taskRECORD_READY_PRIORITY()
                vListInsertEnd()
                  listTEST_LIST_INTEGRITY()
                    configASSERT()
                  listTEST_LIST_ITEM_INTEGRITY()
                    configASSERT()
                  mtCOVERAGE_TEST_DELAY()
